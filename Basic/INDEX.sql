/***********************************************************************************************************
INDEX
  * 인덱스 역할은 조회 성능 향상
  * [DML] SELECT뿐 아니라, UPDATE, DELETE 수행도 해당 대상을 조회해야만 작업할 수 있으므로 인덱스가 필요함
    - INSERT : 해당 테이블의 인덱스에 정해진 위치값을 추가해야 하므로, 그 위치를 찾는데에 부하가 뒤따름
    - DELETE : 삭제 될 데이터의 인덱스 값을 찾아, 연결고리(LINK)를 제거해야 함
    - UPDATE : DELETE와 INSERT가 동시에 발생하므로 부하량이 가장 큼
  * 하나의 테이블에는 여러 개의 인덱스 생성 가능
  * 동일한 컬럼으로 인덱스 생성 불가
  * 잘못된 인덱스 선정은 스토리지 용량을 낭비함
    - 인덱스 생성 자체가 디스크에 실제 인덱스 데이터를 저장하는 행위기 때문에, 용량 낭비로 이어질 수 있음
***********************************************************************************************************/


--(1) 인덱스가 필요한 SQL문
---- COL2 = '100'인 데이터를 추출해야 UPDATE가 가능하므로, 이런 경우에도 테이블 조회가 발생하기 때문에 인덱스가 필요함
UPDATE TAB1
SET COL1 = 'AAA'
WHERE COL2 = '100'
;


-- (2) 잘못된 인덱스 사용
SELECT COUNT(*) SVC_LINE_CNT
FROM ZT_LOG
WHERE A BETWEEN TO_CHAR(SYSDATE, 'YYYYMMDD') || '000000'  --선분조건
      AND B = :1                                          --점조건
      AND C = :2                                          --점조건
      AND D = :3                                          --점조건
;
--- 위 SQL 문에서 INDEX의 종류가 A+B+C+D와 B+C+D+A가 있다면, B+C+D+A(점+점+점+선분)가 성능이 더 좋은 경우이다.
--- 만약 A+B+C+D INDEX를 사용한다면, 조회 선응에 차이가 발생할 것이다.
--- 결과적으로 인덱스의 목적은 조회 성능 향상이지만, 잘못된 인덱스는 조회성능과 DML 작업 성능을 하락시킨다.
--- 또한 잘못된 인덱스 선정은 스토리지 용량을 낭비함을 유의하여야 한다.
